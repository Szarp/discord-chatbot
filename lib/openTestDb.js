import fetch from "node-fetch";
import assert from "assert";
import { URL } from "url";

/**
 * Fetches questions satysfying the query from the Open Trivia Database
 * @param {number} number The number of questions to retrieve
 * @param {keyof typeof import("./opentdbConfig.json").trivia_category} [category] The requested category. Can be `undefined` to fetch all categories
 * @param {keyof typeof import("./opentdbConfig.json").trivia_difficulty} [difficulty] The requested difficulty. Can be `undefined` to fetch questions of any difficulty
 * @param {keyof typeof import("./opentdbConfig.json").trivia_type} [type] The requested question type. Can be `undefined` to fetch questions of any type
 * @returns {Promise<OpentdbQuestion[]>} An array of URL encoded questions. Example (look at "results"): https://opentdb.com/api.php?amount=10&encode=url3986
 */
export async function getQuestions(number = 10, category = "any", difficulty = "any", type = "any") {
	if (!Number.isInteger(number)) {
		throw new Error("The number of questions must be an integer");
	}
	if (number > 50) {
		throw new Error("A Maximum of 50 Questions can be retrieved per call.");
	}
	if (number < 1) {
		throw new Error("The number of requested questions must be greater than 0.");
	}
	let url = new URL("https://opentdb.com/api.php?encode=url3986");
	url.searchParams.append("amount", number.toString());
	if (category !== "any") {
		url.searchParams.append("category", category);
	}
	if (difficulty !== "any") {
		url.searchParams.append("difficulty", difficulty);
	}
	if (difficulty !== "any") {
		url.searchParams.append("type", type);
	}
	const response = await fetch(url);
	if (response.status !== 200) {
		throw new Error("Received a response with a status code other than 200");
	}
	const data = await response.json();
	if (data?.response_code === 1) {
		// Not enough questions satisfying query
		if (category !== "any") {
			const qNum = await getNumberOfQuestions(category);
			if (qNum !== null) {
				throw new Error(`Could not return results. The API doesn't have enough questions for your query.
The total number of questions (of any type) in the requested category is ${qNum.total}:
• easy: ${qNum.easy}
• medium: ${qNum.medium}
• hard: ${qNum.hard}`);
			}
		}
		throw new Error("Could not return results. The API doesn't have enough questions for your query.");
	}
	if (data?.response_code !== 0) {
		throw new Error(`The query to opentdb failed with code ${data?.response_code}`);
	}
	if (!Array.isArray(data?.results)) {
		throw new Error("The results property is not an array");
	}
	if (data.results.length !== number) {
		throw new Error(`The number of received messages (${data.results.length}) is different than requested (${number}).`);
	}
	return parseQuestions(data.results);
}

/**
 * Retrieves the number of questions in the selected category.
 * @param {keyof typeof import("./opentdbConfig.json").trivia_category} category The requested category
 * @returns {Promise<{total: number, easy: number, medium: number, hard: number}?>} An object with numbers of questions in the selected category
 */
async function getNumberOfQuestions(category) {
	assert.notStrictEqual(category, "any");
	let response;
	try {
		response = await fetch(`https://opentdb.com/api_count.php?category=${category}`);
	} catch (_) {
		return null;
	}
	if (!response.ok) {
		return null;
	}
	const json = await response.json();
	if (typeof json?.category_question_count?.total_question_count !== "number" ||
		typeof json?.category_question_count?.total_easy_question_count !== "number" ||
		typeof json?.category_question_count?.total_medium_question_count !== "number" ||
		typeof json?.category_question_count?.total_hard_question_count !== "number") {
		return null;
	}
	return {
		total: json.category_question_count.total_question_count,
		easy: json.category_question_count.total_easy_question_count,
		medium: json.category_question_count.total_medium_question_count,
		hard: json.category_question_count.total_hard_question_count
	};
}

/**
 * Parses the questions from the api to make sure that they are using the correct format
 * @param {any[]} questions The array of questions received from API
 * @returns An array of well formatted questions
 */
function parseQuestions(questions) {
	/** @type {OpentdbQuestion[]} */
	let validQuestions = [];
	for (let question of questions) {
		if (question === undefined ||
			question.type !== "multiple" && question.type !== "boolean" ||
			question.difficulty !== "easy" && question.difficulty !== "medium" && question.difficulty !== "hard" ||
			typeof question.category !== "string" || question.category.length === 0 ||
			typeof question.question !== "string" || question.question.length === 0 ||
			typeof question.correct_answer !== "string" || question.correct_answer.length === 0 ||
			!Array.isArray(question.incorrect_answers)) {
			continue;
		}
		question.category = decodeURIComponent(question.category);
		question.question = decodeURIComponent(question.question);
		question.correct_answer = decodeURIComponent(question.correct_answer);
		let incorrect_answers = [];
		for (const ans of question.incorrect_answers) {
			if (typeof ans !== "string" || ans.length === 0) {
				continue;
			}
			incorrect_answers.push(decodeURIComponent(ans));
		}
		question.incorrect_answers = incorrect_answers;
		validQuestions.push(question);
	}
	return validQuestions;
}

/**
 * @typedef {Object} OpentdbQuestion
 * @property {"multiple" | "boolean"} opentdbQuestion.type
 * @property {"easy" | "medium" | "hard"} opentdbQuestion.difficulty
 * @property {string} opentdbQuestion.category
 * @property {string} opentdbQuestion.question
 * @property {string} opentdbQuestion.correct_answer
 * @property {string[]} opentdbQuestion.incorrect_answers
 */
